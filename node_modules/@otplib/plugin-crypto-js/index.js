/**
 * @otplib/plugin-crypto-js
 *
 * @author Gerald Yeo <contact@fusedthought.com>
 * @version: 12.0.1
 * @license: MIT
 **/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var cryptoJsCore = _interopDefault(require('crypto-js/core'));
var SHA1 = _interopDefault(require('crypto-js/hmac-sha1'));
var SHA256 = _interopDefault(require('crypto-js/hmac-sha256'));
var SHA512 = _interopDefault(require('crypto-js/hmac-sha512'));
var Hex = _interopDefault(require('crypto-js/enc-hex'));
var core = require('@otplib/core');
const Buffer = require('buffer')
const {
  WordArray
} = cryptoJsCore.lib;
function cryptoEncoder(algorithm) {
  switch (algorithm) {
    case core.HashAlgorithms.SHA1:
      return SHA1;
    case core.HashAlgorithms.SHA256:
      return SHA256;
    case core.HashAlgorithms.SHA512:
      return SHA512;
    default:
      throw new Error(`Expecting argument 0 to be one of ${core.HASH_ALGORITHMS.join(', ')}. Received ${algorithm}.`);
  }
}
const createDigest = (algorithm, hmacKey, counter) => {
  const encoder = cryptoEncoder(algorithm);
  const message = Hex.parse(counter);
  const secret = Hex.parse(hmacKey);
  return String(encoder(message, secret));
};
const createRandomBytes = (size, encoding) => {
  const words = WordArray.random(size);
  return Buffer.from(words.toString(), 'hex').toString(encoding);
};

exports.createDigest = createDigest;
exports.createRandomBytes = createRandomBytes;
